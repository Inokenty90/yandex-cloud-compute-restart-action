// autogenerated file

import * as grpc from 'grpc';
import { util } from 'protobufjs';
import Long = util.Long;
import * as events from 'events';
import { Session } from '../../../../index.js';

import * as protobuf from '../../../../contrib/google/protobuf';
import * as operation from '../../../../api/operation';
import * as Trigger from '../../../../Trigger';

export interface Predicate {
  andPredicate?: AndPredicate;

  fieldValuePredicate?: FieldValuePredicate;
}

export interface AndPredicate {
  predicate?: Predicate[];
}

export interface FieldValuePredicate {
  fieldPath: string;

  /**
   * string representation of the value matches exactly to the given string
   */
  exact?: string;

  /**
   * string representation of the value matches exactly to the given string
   */
  prefix?: string;

  /**
   * value has given prefix
   */
  suffix?: string;
}

export enum TriggerType {
  TRIGGER_TYPE_UNSPECIFIED = 0,

  MESSAGE_QUEUE = 3
}

export interface Trigger {
  /**
   * ID of the trigger.
   */
  id?: string;

  /**
   * ID of the folder that the trigger belongs to.
   */
  folderId: string;

  /**
   * Timestamp when the trigger was created.
   */
  createdAt?: protobuf.Timestamp;

  /**
   * Name of the trigger.
   */
  name: string;

  /**
   * Description of the trigger.
   */
  description?: string;

  /**
   * Resource labels as `key:value` pairs.
   */
  labels?: { [s: string]: string };

  /**
   * Defines trigger rule (is always consistent with type filed)
   */
  rule: Trigger.Rule;
}

export namespace Trigger {
  export interface Rule {
    messageQueue?: MessageQueue;

    iotMessage?: IoTMessage;
  }

  export interface MessageQueue {
    /**
     * ARN stands for Amazon Resource ID. ARN is the only way to uniquely
     * identify a queue in the YMQ. One is expected to use it as a reference
     * to a queue when creating a trigger.
     */
    arn?: string;

    /**
     * SA which has read access to the queue.
     */
    serviceAccountId: string;

    /**
     * Batch settings for YMQ client.
     */
    batchSettings: BatchSettings;

    invokeFunction?: InvokeFunctionOnce;
  }

  export interface IoTMessage {
    registryId: string;

    deviceId?: string;

    mqttTopic?: string;

    invokeFunction?: InvokeFunctionWithRetry;
  }
}

export interface InvokeFunctionOnce {
  functionId: string;

  functionTag?: string;

  /**
   * SA which should be used to call a function, optional.
   */
  serviceAccountId?: string;
}

export interface InvokeFunctionWithRetry {
  functionId: string;

  functionTag?: string;

  /**
   * SA which has call permission on the function, optional.
   */
  serviceAccountId?: string;

  /**
   * Retry policy, optional (no value means no retry).
   */
  retrySettings?: RetrySettings;
}

export interface BatchSettings {
  /**
   * Maximum batch size: trigger will send a batch if number of events exceeds this value.
   */
  size?: Long;

  /**
   * Maximum batch size: trigger will send a batch if its lifetime exceeds this value.
   */
  cutoff: protobuf.Duration;
}

export interface RetrySettings {
  /**
   * Maximum number of retries (extra calls) before an action fails.
   */
  retryAttempts?: Long;

  /**
   * Interval between tries.
   */
  interval: protobuf.Duration;
}

export class TriggerService {
  constructor(session?: Session);
  get(request: GetTriggerRequest): Promise<Trigger>;

  list(request: ListTriggersRequest): Promise<ListTriggersResponse>;

  create(request: CreateTriggerRequest): Promise<operation.Operation>;

  update(request: UpdateTriggerRequest): Promise<operation.Operation>;

  delete(request: DeleteTriggerRequest): Promise<operation.Operation>;

  listOperations(request: ListTriggerOperationsRequest): Promise<ListTriggerOperationsResponse>;
}

export interface GetTriggerRequest {
  triggerId: string;
}

export interface ListTriggersRequest {
  folderId: string;

  pageSize?: Long;

  pageToken?: string;

  filter?: string;
}

export interface ListTriggersResponse {
  triggers?: Trigger[];

  nextPageToken?: string;
}

export interface CreateTriggerRequest {
  folderId: string;

  name?: string;

  description?: string;

  labels?: { [s: string]: string };

  rule: Trigger.Rule;
}

export interface CreateTriggerMetadata {
  triggerId?: string;
}

export interface UpdateTriggerRequest {
  triggerId: string;

  updateMask?: protobuf.FieldMask;

  name?: string;

  description?: string;

  labels?: { [s: string]: string };
}

export interface UpdateTriggerMetadata {
  triggerId: string;
}

export interface DeleteTriggerRequest {
  triggerId: string;
}

export interface DeleteTriggerMetadata {
  triggerId: string;
}

export interface ListTriggerOperationsRequest {
  triggerId: string;

  pageSize?: Long;

  pageToken?: string;

  filter?: string;
}

export interface ListTriggerOperationsResponse {
  operations?: operation.Operation[];

  nextPageToken?: string;
}
